# 1. 重构，第一个示例

- 如果程序杂乱无章，先为它整理出结构来，再做需要的修改，通常来说更简单

​    `如果你要给程序加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易修改`

- 是需求的变化使重构变的重要

## 1.1 重构的第一步

​    每当我要进行重构的时候，第一个步骤永远相同：我得确保即将修改的代码有`一组可靠的测试`。因为程序越大，我的修改不小心破坏其他代码的可能性就越大

​    重构之前，先检查自己是否有一套可靠的测试集。这些测试必须有自我检验能力。现代的测试框架提供了丰富的设施，支持编写和运行能够自我检验的测试。

​    测试——bug检测器，能够保护自己不被自己犯的错误所困扰。尽管编写测试需要花费时间，但是因为对程序员自身的工作进行了二次确认，节省了可观的调试时间。

---------

​    **提炼函数**：将一块代码抽取成函数

 	1. 首先检查一下有哪些变量会离开本来的作用域（更关心那些会被修改的变量），需要注意会被修改的变量，类似于可以直接从函数中返回
 	2. 做完改动后，马上编译并执行一遍测试，看看有无破坏了其他东西。
 	3. 无论重构有多简单，养成重构后立即测试的习惯非常重要
 	4. 精髓：小步修改，每次修改后就测试。

- 重构技术就是以微小的步伐修改程序。如果你犯下错误，很容易便可以发现它。

​    **完成提炼函数后，我会看看提炼出来的函数**，看是否能进一步提升其表达能力，

1. 一般做的第一件事就是给一些变量重新命名

2. 然后前往下一个目标——函数参数

   `使用一门动态类型语言时，跟踪变量的类型很有意义，因此“我”为参数取名时都默认带上其类型名`

- 唯有写出人类容易理解的代码的，才是优秀的程序员

​    如果只要改名能够提升代码的可读性，那么应该毫不犹豫去做。

​    “我”喜欢将play这样的变量移除掉，因为它们创建了很多具有局部作用域的临时变量，这会使提炼函数更加复杂。

**重构手法**：以查询取代临时变量--

1. 以查询取代临时变量
2. 编译，测试，提交，然后使用内联变量手法内联play变量
3. 编译，测试，提交。完成变量内联后
4. 再看看能不能减去参数，然后再编译测试提交

- 使用查询更好，移除局部变量的好处就是做提炼的时候会简单很多，因为需要操心的局部作用域变少了。实际上在做任何提炼前，我一般都会先移除局部变量

实际过程中最好每次改名后执行编译、测试、提交

- 这个一般使用result作为返回结果，但是前提得是函数命名也没有问题

查询取代临时变量，临时变量实际上是鼓励你写长而复杂的函数，因此，下一步要替换掉一些临时变量

**“将函数赋值给临时变量”的场景，我更愿意将其替换为一个明确声明的函数**

- 好的命名十分重要，但往往并非唾手可得。只有恰如其分的命名，才能彰显出将大函数分解成小函数的价值。有了好的名称，我们就不必通过阅读函数体来了解其行为。通常你需要花几秒通读更多代码，才能发现最好的名称是什么

如果某个变量是在循环的迭代过程中累加得到的，要将其分离出来：

1. 第一步，就是应用拆分循环，将volumeCredits的累加过程分离出来

2. 完成这一步，就可以使用移动语句的手法将变量声明挪动到紧邻循环位置

   把与更新volumeCredits变量相关的代码都集中到一起，有利于以查询取代临时变量手法的施展。

   1. 第一步同样是先对变量的计算过程应用提炼函数手法
   2. 完成函数提炼后，再应用内联变量手法内联相关函数，即除去临时变量

软件的性能通常只与代码的一小部份相关，改变其他的部份往往对总体性能贡献甚微

- 但是，有了一份结构良好的代码，回头调优其性能也容易的多；很多时候，重构可以使我使用更高效的调优方案，最后得到既整洁又高效的代码

result作为返回的结果

代码结构：尽量让顶层函数只剩下处理逻辑，与计算相关的逻辑都从主函数移除

## 1.2 拆分计算阶段与格式化阶段

**重构早期的一般步骤：**为原函数添加足够的结构，以便更好的理解它，看清它的逻辑结构。

要复用有许多方法：如何去复用也很麻烦

每次重构，可以每做一次微小的改变就提交到自己的分支上，然后再集成一次大的成果合并到主分支

移除局部变量的好处很多

上层函数尽量只剩下逻辑表达

作为在两个阶段间传递的中转数据结构，然后将它第一个参数

我们要检查一下renderPlainText用到的其他参数，这样所有计算代码都可以被移到statement函数中，让renderPlainText只操作data参数传入的数据

更喜欢显式地去传入参数

忍不住利用管道代替循环

### 1.3 分离到两个文件

`Object.assign({},aPerformance)`是一个浅拷贝

虽然代码的长度变长了，但是可读性也提高了，额外的包装将混杂的逻辑分解成可分辨的逻辑

- 编程时，一定要遵循营地规则：保证你离开时的代码库一定比来时更健康

之前重构带来的一大好处是，现在大可以去忽视那些格式化代码，只要不改变中转数据即可

enrichPerformance函数是关键，因为正是它每场演出的数据来填充中转数据，目前它直接调用了计算价格和观众量积分的函数，我需要创建一个类，通过这个类来调用这些函数。由于这个类存放了每场演出相关数据的计算函数，于是我把它称为演出计算器

将函数行为搬移到新对象中，这可以从最容易搬移的东西开始

​    使新函数适应新家后，我会将原来的函数改造成一个委托函数，让它直接调用新函数。然后编译、测试、提交，确保代码搬家后也能用的情况下，再使用内联

​    要得到正确的子类，我需要将构造函数调用替换为一个普通的函数调用，因为js的构造函数里面无法返回子类，于是使用工厂函数取代构造函数

### 1.4 使用多态计算机来提供数据

​    本章的重构有3个比较重要的点：

1. 将原函数分解成一组嵌套的函数
2. 应用拆分阶段分离计算逻辑与输出格式化逻辑
3. 为计算机引入多态性来处理计算逻辑

好代码应该直接了当，一个健康的代码库能够最大限度地提升我们的生产力而不引入错误。

- 好代码的检验标准就是人们是否能轻而易举地修改它

- 小的步子可以更快前进，请保持代码永远处于可工作状态，小步积累起来也能大大改善系统的设计

## 2. 重构的原则

### 2.1 何谓重构

​    重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。

​    重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

重构的关键在于运用大量微小且保持软件行为的步骤，一步步达成大规模的修改。

- 如果有人说他们的代码在重构过程中有一两天时间不可用，基本上可以确定，他们不在重构

​    小步前进会使得最后走的更快，因为这些小步骤能完美地匹配彼此，更关键的是，在小步前进的过程中，不会花任何时间来调试

​    重构的目的是为了让代码“更容易理解”，更易于“修改”，这可能使代码运行地更快，也可能让代码运行的更慢，在性能优化方面，我只关心让程序运行的更快，最终得到的代码有可能更难理解与维护。

​    开发软件时，时间分给两种行为：开发新功能和重构

### 2.2 为何重构

#### 2.2.1 重构改进软件的设计

​    如果没有重构，程序的内部设计（或者叫架构）会逐渐腐败变质。当人们为了短期目的而修改代码时，他们经常没有完全理解架构的整体设计，于是代码逐渐失去了自己的结构。程序员越难通过阅读源码来理解原来的设计。代码结构的流失有累积效应。越难看出代码所代表的设计意图，就越难保护其设计，于是设计腐败的就越快。经常性的重构有助于代码维持自己该有的形态。

​    改进设计的一个重要方向就消除重复代码，代码量的减少并不会使系统运行的更快，因为这对程序的资源占用几乎没有任何明显的影响，然而代码量的减少将使未来可能的程序修改动作容易的多。消除重复代码，我就可以确定所有事物和行为在代码中只表述一次，这正是优秀设计的根本。

#### 2.2.2 重构使软件更容易理解

​    因为你写的代码有可能被下一个人所维护

#### 2.2.3 重构帮助找到bug

​    如果对代码进行重构，我就可以深入理解代码的行为，并立即将新的理解反映在代码当中，

​    重构帮助我更有效地写出鲁棒的代码。

#### 2.2.4 重构提高编程速度

​    重构帮我更快地开发程序，虽然听起来有点反常识。良好的模块划分使得我只需要理解代码库中的一小部份，就可以做出修改，如果代码很清晰，那么引入bug的可能性就会变小，即使引入了bug，调试也会容易得多。

​    **设计耐久性假设**：通过投入精力改善内部设计，我们增加了软件的耐久性，从而可以更长时间地保持开发的快速。由于预先做出良好的设计非常困难，想要既体面又快速地开发功能，重构必不可少

### 2.3 何时进行重构

​    **三次法则**：第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。

​    **预备性重构**：重构的最佳时机就在添加新功能之前，在动手添加新功能之前，我会看看现有的代码库，此时经常会发现：如果对代码结构做一点微调，我的工作会容易的多。也许已经有个函数提供了我需要的大部份功能，但是有几个字面量的值与我的需要有冲突，如果不做重构，我可能会把整个函数赋值过来，修改这几个值，但这就会导致重复代码——而且将来如果我需要修改，就必须修改两处。所以我带上重构的帽子，使用函数参数化。

​    通过重构，就把脑子里的理解转移到了代码本身。随后运行这个软件，看看是否能够正常工作，来检查这些理解是否正确。

- 我常常会在一些小细节上使用重构来帮助理解，给一两个变量改名，让它们更清楚地表达意图，以方便理解，或是将一个长函数拆成几个小函数。当代码变得更清晰一点，我就会看见之前看不见的设计问题，但是如果不做之前的重构，我就永远看不见这些设计问题。如果只是阅读代码很难有这样的理解

​    **捡垃圾重构**：如果我发现的垃圾很容易重构，我会马上重构它；如果重构需要花费一些精力，我可能完成当下的任务后再回来重构它。至少要让营地比你来的时候更加干净

- 肮脏的代码必须重构，但漂亮的代码也需要很多重构

​    添加新功能最快的方法往往是先修改现有的代码，使新功能容易被加入，每当需要新功能时，软件就应该做出相应的改变。但是有计划的重构应该很少，大部份重构应该是不起眼的、见机行事的。

​    如果想要替换掉一个正在使用的库，那么可以先引入一层新的抽象，使其兼容新旧两个库的接口。

​    一个比较有争议的建议：不要告诉经理

- 重构的唯一目的就是让我们开发的更快，用更少的工作量创造更大的价值

在这个行业里，重构不足的情况远多于重构过度的情况

​    重视代码库的改善，重视代码库的健康，这个是重要的；重构是经济利益驱动的，好的设计那条曲线就容易出现

​    代码所有权的边界会妨碍重构，因为一旦我自作主张地修改，就一定会破坏使用者的程序。但这不会完全阻止重构，仍然可以做很多的重构，但确实对重构造成约束。为了避免破坏使用者的系统而不得不付出的代价，可以把旧的接口标记为（不推荐使用），等一段时间后最终让他完全退休

​    推荐团队代码所有制，这样一支团队里的成员都可以修改这个团队拥有的代码，即使最初写代码的是别人。程序员可能各自分工系统的不同区域，但这种责任应该体现为监控自己责任区内发生的修改，而不是简单粗暴地禁止别人修改。

​    分支修改方法，应该尽量减少分支存在的时长；Continuous Integration，在使用CI的时候，每个团队成员每天至少向主线集成一次。

​    “快速发现错误”也很重要，这就是测试所在的地方了；自测试代码和持续集成紧密相关。

​    重构可以很好地帮助我们理解遗留系统；每次触碰一块代码时，尝试让他变得好一点点

​    很多时候，数据库的重构最好分散到多次生产发布来完成，这样即使某次修改在生产数据库上造成了问题，也比较容易回滚

​    修改遗留代码经常很有挑战，尤其当遗留代码缺乏恰当的测试的时候

​    灵活性机制

​    有了重构技术，就可以采用不同的策略。与其猜测未来需要哪些灵活性，需要什么机制来提供灵活性，我更愿意只根据当前的需求来构造软件，同时把软件的设计质量做的很高。如果一种灵活性机制的引入会使得如那件复杂，那么就要先证明自己是值得引入的；即评估以后再重构有多困难，只有当未来重构很困难的时候，才会考虑现在加入灵活性机制。

​    要真正以敏捷的方式运行项目，团队成员必须在重构上有能力、有热情，他们采用的开发过程必须与常规的、持续的重构相匹配。

- 重构的第一块基石是自测试代码。我应该有一套自动化的测试，我可以频繁地运行它们，并且有信心：如果在编程中犯了任何错误，会有测试失败。这块基石如此重要。

- 三大实践——自测试代码、持续集成和重构——彼此间有很强的协同效应

持续的集成能帮我们降低风险，并使我们做到根据业务去随时安排发布。

​    虽然重构使软件可能运行的更慢，但是更方便去做性能优化：先写出可以调优的代码，然后再进行调优

​    哪怕你完全了解系统，也请实际度量它的性能，不要进行臆测。臆测会让你学到一些东西，但十有八九你都是错误的。

​    在性能优化阶段，我首先应用一个度量工具来监控程序的运行，让他告诉我程序中哪些地方大量消耗时间和空间；性能优化和重构差不多，小步修改，慢慢改进。自动化重构和手工重构相配合

## 3. 代码的坏味道

### 3.1 神秘命名

​    命名是编程最难的两件事之一，改名是最常用的重构手法，包括改变函数声明、变量改名、字段改名等。

### 3.2 重复代码

​    如果你在一个以上的地点看到相同的代码结构，那么可以肯定，设法将它们合二为一，程序会变得更好，一旦有重复代码存在，阅读这些重复的代码时你就必须加倍仔细，留意其细微的差异。如果要修改所有重复代码，你必须找出所有的副本来修改

​    最单纯的重复代码就是同一个类的两个函数含有相同表达式，这时候你需要做的就是采用提炼函数提炼出重复的代码，然后让这两个地点都调用那个被提炼出来的那一段代码。如果重复代码只是相似而不是完全相同，请首先尝试移动语句重组代码顺序，把相似的部份放在一起以便提炼。如果重复的代码位于同一个超类的不同子类内，可以使用函数上移的方式来避免两个子类之间的调用

### 3.3 过长函数

​    活的最长、最好的程序，其中的函数都比较短。初次接触这种代码库的程序员常常会觉得“计算都没有发生”程序里满是无穷无尽的委托调用。间接性带来的好处——更好的阐述力、更易于分享、更多的选择，都是由小函数支持的。

- 现代编程语言几乎已经完全免除了进程内的函数调用开销。固然小函数会给代码的阅读者带来一些负担，因为你必须经常切换上下文，才能看明白函数再做什么。但现代的开发环境让你可以在函数的调用处和声明处之间快速跳转。如果你给函数起了好名字，阅读代码的人就可以通过名字了解函数的作用，根本不必去看其中写了什么

​    **你应该更积极地分解函数**：我们遵循这个原则：每当感觉需要以注释来说明点什么的时候，我们就需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）进行命名。

​    我们可以对一组甚至短短一行代码做这件事，哪怕替换后的函数调用动作比函数自身要长，只要函数名称能够解其用途，我们也该毫不犹豫地那么做。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离

​    如果函数内有大量的参数和临时变量，它们会对你的函数提炼形成障碍，如果你尝试提炼函数。最终就会把许多参数传递给被提炼出来的新函数，导致可读性几乎没有变化。此时，你可以经常运用查询取代临时变量来消除这些临时元素。引入参数对象和保持对象完整则可以将过长的参数列表变得更加整洁一点。

​    如果这样做了后依旧有太多的临时变量和参数，那么就可以使出杀手锏——以命令取代函数

​    如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，并且可以在注释的基础上给这个函数命名。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数中去

​    条件表达式和循环常常也是提炼的信号。你可以分解条件表达式处理条件表达式。对于庞大的switch语句，其中的每个分支都应该通过提炼函数变成独立的函数调用。如果有多个switch基于一个条件进行分支选择，那么就应该使用多态取代条件表达式

​    至于循环，你应该将循环和循环内的代码提炼到一个独立的函数中，如果你发现提炼出的循环很难命名，可能是因为其中做了几件不同的事情，如果是这种情况，请勇敢地拆分循环将其拆分成各自独立的任务

### 3.4 过长参数列表

​    如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以查询取代参数去掉第二个参数

​    如果你发现自己正在从现有数据结构中抽出很多数据项，就可以考虑使用保持对象完整手法，直接传入原来的数据结构。如果有迹象参数总是同时出现，可以引入参数对象将其合并为一个对象。如果某个参数被用作区分函数行为的标记，可以使用移除标记参数。

​    使用类可以有效地缩短参数列表。

### 3.5 全局数据

​    全局数据——最刺鼻的坏味道之一，它的问题在于，从代码库的任何一个角落都能修改它，而且没有任何的bug，而问题的根源却在遥远的别处，想要找出出错的代码难于登天。全局数据最显而易见的就是全局变量，但类变量和单例也有这样的问题。

​    首先的防御手段是封装变量，你可以把全局变量用一个函数包装起来，至少你就能看到修改它的地方，并开始控制对它的访问。随后，最好将这个函数搬移到一个类或模块中，只允许模块内的代码使用它，从而尽量控制其作用域。

### 3.6 可变数据

​    对数据的修改经常导致出乎意料的结果和难以发现的bug。函数式编程

​    可以用封装变量来确保所有数据更新操作都通过很少几个函数来进行，使其更容易监控和演进。如果一个变量在不同时候被用于存储不同的东西，可以使用拆分变量将其拆分为各自不同用途的变量，从而避免危险的更新操作。使用移动语句和提炼函数尽量把逻辑从处理更新操作的代码中搬移出来，将没有副作用的代码与执行数据更新操作的代码分开。设计API时，可以使用将查询函数和修改函数分离，确保调用者不会调到有副作用的代码，除非他们真的需要更新数据，我们还乐于使用移除设值函数——有时只是把设值函数的使用者找出来看看，就能帮我们发现缩小变量作用域的机会。

### 3.7 发散式变化

​    一旦需要修改，我们希望能够跳到系统的某一点，只在该处做修改。

​    如果某个模块经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了。“每次只关心一个上下文很重要”；如果这两个模块处理的是两个不同的上下文，将它们分别搬迁到各自独立的模块中，能让程序更好。

​    如果发生变化的两个方向自然地形成了先后次序，就可以使用拆分阶段将两者分开，两者之间通过一个清晰的数据结构进行沟通。如果两个方向之间有更多的来回调用，就应该先创建适当的模块，然后搬移函数将处理逻辑分开。如果函数内部混合了两类处理逻辑，应该先用提炼函数将其分开，然后再做搬移。如果模块是以类的形式定义的，就可以用提炼类来做拆分。

### 3.8 霰弹式修改

​    类似于发散式修改，但又恰恰相反。如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，那就是咸蛋修改。即便如此钟爱小型的函数或类，我们也并步担心在重构的过程中暂时创建一些较大的程序单元





