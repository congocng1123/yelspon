## 1. 时间复杂度

常数操作：固定时间，和数据本身没有关系，与数据量无关

- 在常数表达式中，忽略掉低阶项，只要高阶项，并且忽略掉高阶项系数

  原因：在数据量很大的时候，常数和低阶项就会相对越来越小

同样的指标怎么拼好坏：这个时候就要去拼常数项了

但是不能只用理论值去估计，因为不同的运算的速度不一定一样，需要实际去计算，给一个大数据量的东西去跑，去分析它们实际的时间差别。

## 2. 异或运算

解释：相同为1，不同为0

- 异或运算还可以理解成无进位相加
- 异或运算满足交换律和结合率

### 2.1 **如何使用异或运算交换两个数的值**

1. a = a ^ b;

2. b = a ^ b;

3. a = a ^ b;

- 满足交换律和结合率
- 一个数和0异或等于它本身
- 一个数和自己异或等于0
- 但是前提是a和b在内存里是独立的两块区域，且a和b的值不相等

### 2.2 **无进位相加**

1. 一个数出现了奇数次，其他数都出现了偶数次，只需要一个数，然后循环异或，最后得到的值就是那个奇数次

2. 两个数出现了奇数次，其他数都是偶数次，如何找到两个出现奇数次的数？
   - 仍然准备一个eor，eor = a^b不是0，如何得到a或者b呢
   - 这个时候eor不为0，则我们能找出a和b不一样的数位，就选择某个数位是1的数，异或上那个位置是1的数，就可以得到a。
   - 如果再去异或那个位置上为0的数，就可以得到b
   - 就是利用eor的特点去分开a和b

位运算是最快的，比算数运算快多了

## 3. 插入排序

### 3.1 介绍

插入排序是从0*0 到0～N，先将前面的有序化，然后再取出值插入到数组之中

### 3.2 特点

- 数据状况不同，会导致时间复杂度不一样

- 插入排序比冒泡排序和选择排序好一些

  因为冒泡排序和选择排序的实际时间和数据状况无关

## 4. 二分法

二分法去找有序数组中的数，时间复杂度为O(log2N)

### 4.1 二分排序

在一个数组中，找到大于等于某个数的最左侧位置...一直二分，就不断二分直到最小数组

**局部最小值如何计算**：就是求极小值，也可以使用二分法

### 4.2 对数器

测量时间复杂度的时候，别只用线上测试的测试数据，这时候要用对数器的方法

- 不追求时间复杂度的算法好写，但是追求时间复杂度的算法难写

## 5. 递归:master公式

当`T(N) = a*T(N/b)+O(N^d)`的时候就可以使用master公式

1. Log(b,a) > d
   - 时间复杂度为`O(N^log(b,a))`

2. log(b,a) < d
   - 时间复杂度为`O(N^d)`

3. Log(b,a) == d
   - 时间复杂度为`O(N^d * logN)`

## 6. 归并排序

