## 1. 时间复杂度

常数操作：固定时间，和数据本身没有关系，与数据量无关

- 在常数表达式中，忽略掉低阶项，只要高阶项，并且忽略掉高阶项系数

  原因：在数据量很大的时候，常数和低阶项就会相对越来越小

同样的指标怎么拼好坏：这个时候就要去拼常数项了

但是不能只用理论值去估计，因为不同的运算的速度不一定一样，需要实际去计算，给一个大数据量的东西去跑，去分析它们实际的时间差别。

## 2. 异或运算

解释：相同为1，不同为0

- 异或运算还可以理解成无进位相加
- 异或运算满足交换律和结合率

### 2.1 **如何使用异或运算交换两个数的值**

1. a = a ^ b;

2. b = a ^ b;

3. a = a ^ b;

- 满足交换律和结合率
- 一个数和0异或等于它本身
- 一个数和自己异或等于0
- 但是前提是a和b在内存里是独立的两块区域，且a和b的值不相等

### 2.2 **无进位相加**

1. 一个数出现了奇数次，其他数都出现了偶数次，只需要一个数，然后循环异或，最后得到的值就是那个奇数次

2. 两个数出现了奇数次，其他数都是偶数次，如何找到两个出现奇数次的数？
   - 仍然准备一个eor，eor = a^b不是0，如何得到a或者b呢
   - 这个时候eor不为0，则我们能找出a和b不一样的数位，就选择某个数位是1的数，异或上那个位置是1的数，就可以得到a。
   - 如果再去异或那个位置上为0的数，就可以得到b
   - 就是利用eor的特点去分开a和b

位运算是最快的，比算数运算快多了

## 3. 插入排序

### 3.1 介绍

插入排序是从0*0 到0～N，先将前面的有序化，然后再取出值插入到数组之中

### 3.2 特点

- 数据状况不同，会导致时间复杂度不一样

- 插入排序比冒泡排序和选择排序好一些

  因为冒泡排序和选择排序的实际时间和数据状况无关

## 4. 二分法

二分法去找有序数组中的数，时间复杂度为O(log2N)

### 4.1 二分排序

在一个数组中，找到大于等于某个数的最左侧位置...一直二分，就不断二分直到最小数组

**局部最小值如何计算**：就是求极小值，也可以使用二分法

### 4.2 对数器

测量时间复杂度的时候，别只用线上测试的测试数据，这时候要用对数器的方法

- 不追求时间复杂度的算法好写，但是追求时间复杂度的算法难写

## 5. 递归:master公式

当`T(N) = a*T(N/b)+O(N^d)`的时候就可以使用master公式

1. Log(b,a) > d
   - 时间复杂度为`O(N^log(b,a))`

2. log(b,a) < d
   - 时间复杂度为`O(N^d)`

3. Log(b,a) == d
   - 时间复杂度为`O(N^d * logN)`

## 6. 归并排序

需要额外的辅助空间，将数组左边和右边分别进行排序

时间复杂度`O(NlogN)`，空间复杂度为`O(N)`（这里指的是最多只用准备n的空间）

### 6.1 为啥时间复杂度下降了

因为相比于冒泡排序和选择排序，归并排序没有浪费比较行为，而且比较行为的信息被留下来了，变成了一个整体有序的部分，然后merge在一起

**需要注意的点**

- 但是求小数的时候需要注意，当左组的数和右组的数相等的时候，一定要先拷贝右组的数，不然不知道有多少右组的数比左组的数大（求小和问题）

逆序对问题也可以用到归并排序

当涉及到两两比较相关的问题的时候可以使用归并排序

## 7. 快速排序

简而言之：小于等于某个数的放在左侧，大于某个数的放右侧

### 7.1 快排1.0

**步骤**

- 在整个数组中，拿出最后一个数作为划分值，然后划分出三个区域
- 然后再让左侧数组和右侧数组重复这个行为
- 相当于递归，继续不断地重复划分，直到相等的时候即可

快排的好处是空间复杂度比较小

### 7.2 快排2.0

利用荷兰国旗问题，在整个范围上拿最后一个数进行划分，让前面的范围都是小于5，中间为等于5，最后为大于5.

- 这个时候中间等于5的区域就不需要进行改变了
- 快排2.0版本比快排1.0版本要稍微快一点，因为他一次性搞定一批数

但是不管是快排2.0还是快排1.0，其时间复杂度都是`O(NlogN)`

**缺陷**

- 最差情况的时候，划分值打的很偏门，导致划分的情况很差
- 划分值基本上打偏的话，就会退化成O(N^2)的情况
- 可以人为构建差的数据

### 7.3 快排3.0

**核心**

- 在数组L到R的范围上随机选择一个数，和最后一个数进行交换，再进行划分
- 随机选择一个数，好情况和坏情况就是一个概率事件
- 随机选择的数有可能选择到的是最好的情况，也有可能选择到的是最坏的情况
- 这样可以避免人为设置差的情况，表达式是一个相等概率的事件

也是时间复杂度为`O(NlogN)`的一个算法

异或交换两个数只有在这两个数不相等的时候才能使用异或去交换

快排的空间复杂度为`O(logN)`级别

好情况是logN，差情况是N，最终能收敛到logN的水平

## 8. 堆

### 8.1 堆结构

堆是一个完全二叉树结构

满二叉树是一种特殊的完全二叉树

**数组构建成完全二叉树**

- i位置的左孩子为2*i + 1，右孩子为2\*i+2
- i位置的父为(i-1)/2

**大根堆**

- 大根堆的每一颗子树的最大值就是其根节点

- 小根堆则与其相反

  **如何构建一个大根堆**

  1. 将新放进来的值和其父进行比较，如果大于其父就替换
  2. 如果我比我的父要大，就和他交换；上浮和下沉
  3. 不需要比较兄弟节点，自顶向下建立堆
  4. 什么时候来到了头位置，或者不比父大的时候，就不用上浮了

堆结构的本质就是heapinsert和heapify

完全二叉树的高度为logN，即如果一个完全二叉树有N个节点，那么他的高度为logN级别

### 8.2 堆排序

- 先让整个数组整体变成一个大根堆，从0-0，然后0-1，0-2...0-N拓展到整个数组，让整个数组变成一个大根堆

- 然后把最大值和最后一个值交换，把heapsize的值变成heapsize-1
- 然后不断地减少heapsize的值，最后就能排序出一个按顺序的数组
- 每次筛选出最大的值放到最后，但是一次操作的时间复杂度是logN级别的

（二叉树的冒泡/doge)

从上面我们可以知道，可以从上往下依次添数，也可以从下往上依次添数。

叶节点如果是N/2个节点，那么如果从下往上进行大根堆的话，相当于N/2不用动，从下往上去做heapify的话，复杂度会比较低一点

优先级队列结构就是堆，即认为堆顶优先级是最高的

**一道题**

- 如果一个数的操作最多不超过k步，那么可以使用小根堆或者大根堆去一次性计算k+1个位置的最大值or最小值

### 8.3 比较器

比较器实质就是重载比较运算符

## 9.桶排序

之前讲的排序基本上都只和两个数的大小有关，只和比较有关；即之前讲的排序都是基于比较的排序

**不基于比较的排序都是根据数据状况的排序**，相比之下可能没有基于比较的排序有那么广的应用范围

桶就是容器，桶的结构可以是数组，栈，队列等等

**步骤**

1. 先根据个位数字去决定放在哪个桶，然后倒出来
2. 再根据十位数字、百位数字，依次往高处去排序

相当于按照优先级去排序

个位数字的优先级最小，然后十位数大一点，百位数更大，然后更高位更大

10个桶，就可以进行基数排序，如果是十进制

几进制就使用几个桶，前提是有进制这个概念，才可以使用基数排序

## 10.链表

### 10.1 排序算法的稳定性及其汇总

- 同样值的个体之间，如果不因为排序而改变相对次序，就是这个排序是有稳定性，否则就没有
- 相对次序稳定就是稳定排序
- 简单的排序可能不用在意稳定性，但是有的情况下需要去在意稳定性 

**不具备稳定性的排序：**

- **选择排序**（会改变次序，做不到稳定性）

  **时间复杂度**：O(N^2)    **空间复杂度**:O(1)

- **快速排序**(partation的时候就做不到稳定性了)

  **时间复杂度**：O(N*logN)    **空间复杂度**：O(logN)

  快排通过实验后，常数项是最低的，能用快排就用快排

- **堆排序**（把整个数组变成大根堆的过程就已经做不到稳定性了）

  **时间复杂度**：O(N*logN)    **空间复杂度**：O(1)

**具备稳定性的排序:**

- **冒泡排序**

  **时间复杂度**：O(N^2)    **空间复杂度**：O(1)

- **插入排序**（从0-0慢慢增长，直到0-N，关键怎么去处理相等的问题）

  **时间复杂度**：O(N^2)    **空间复杂度**：O(1)

- **归并排序**(关键在于merge的时候怎么去merge，当左侧和右侧相等的时候先去拷贝左边的，就可以做到稳定性)（小和问题是先拷贝右边的，但是小和问题没有稳定性）

  **时间复杂度**：O(N*logN)    **空间复杂度**：O(N)

**总结：**

1. 快排是经过实验后最快的，常数项是最低的，能用快排就用快排（劣势就是稳定性和空间复杂度不能做到O(1)）
2. 堆排序是空间复杂度最小的，当对空间复杂度很敏感的时候，就使用堆排序
3. 归并排序是稳定的排序方式，当需要稳定的排序方式的时候，就使用归并排序（劣势就是空间复杂度高）

**基于比较的排序能不能做到O(N*logN)以下？**

- 目前来讲没有找到，所以默认为没有

**事件复杂度在O(N\*logN)，空间复杂度在O(N)以下能不能做到稳定？**

- 目前来说没有办法，要想稳定性有一定的牺牲，要想时间快就要在别的地方需要牺牲，当你在一个地方需要提升的时候，就需要在另一方面有所牺牲

**常见的坑**

时间截止：27:27